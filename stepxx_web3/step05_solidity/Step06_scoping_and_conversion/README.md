<h2>Variable Scoping and Type Conversion in Solidity</h2>
<p>Understanding variable scoping and type conversion is essential to write efficient and secure code in Solidity. </p>

<h4>Setup Local HardHat Environment With Typescript.</h4>
<p>After setting up hardhat environemnt copy the smart contract, test and deploy script then run the following commands</p>
<ol>
 <li>Compile the smart contract</li>
  <pre><code>npx hardhat compile</code></pre>
  <li>Run scripts to deploy the contracts:</li>
  <pre><code>npx hardhat node</code></pre>
     <pre><code>npx hardhat run scripts/deploy.ts</code></pre>
</ol>

<h4>Remix Test.</h4>
<p> Copy the smart contract and run it in the browser Remix environment <a href="https://remix.ethereum.org/">https://remix.ethereum.org/</a> </p>

<h3>Variable Scoping</h3>
<p>Variable scoping determines the availability of a variable within a function and a contract in Solidity. There are two locations where variables can be declared in Solidity:</p>
<ul>
  <li><strong>Contract-level global variables (state variables):</strong> These variables are available to all functions in a contract, including constructors, fallbacks, and modifiers. Solidity provides three visibility modifiers to control the accessibility of state variables:</li>
    <ul>
      <li><code>public:</code> These state variables are accessible directly from external calls, and a getter function is implicitly generated by the compiler to read the value of public state variables.</li>
      <li><code>internal:</code> These state variables are not accessible directly from external calls. They are accessible from functions within the current contract and child contracts deriving from it.</li>
      <li><code>private:</code> These state variables are not accessible directly from external calls or functions from child contracts. They are only accessible from functions within the current contract.</li>
    </ul>
  <li><strong>Function-level local variables:</strong> These variables are available within a function and cannot be accessed outside the function.</li>
</ul>
<h3>Type Conversion</h3>
<p>Solidity is a statically-typed language, meaning that variables are defined with specific data types at compile time and cannot change types during their lifetime. However, there are times when type conversions are required to copy a value from a variable of one type to another. Solidity supports various kinds of conversions, including implicit and explicit conversions.</p>
<ul>
  <li><strong>Implicit Conversion:</strong> This kind of conversion happens automatically by the compiler when the data type is widened. Solidity allows for implicit conversion from smaller to larger integral types, but not the other way around. For example, converting uint8 to uint16 happens implicitly without requiring an operator or external help for conversion.</li>
<li><strong>Explicit Conversion:</strong> This kind of conversion is required when the compiler does not perform implicit conversion due to a loss of data or a value containing data not falling within a target data type range. Solidity provides a function for each value type for explicit conversion. An example of explicit conversion is `uint16` to `uint8`. Data loss is possible in such a case.</li>



<h4>Learning Resources</h4>
<ul>
  <li><a href="https://docs.soliditylang.org/en/v0.8.19/units-and-global-variables.html">Solidity Documentation - Types</a></li>
  <li>Solidity Essentrials Book CH#4</a></li>
</ul>
